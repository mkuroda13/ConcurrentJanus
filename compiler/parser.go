// Code generated by goyacc -o parser.go -p parser parser.y. DO NOT EDIT.

//line parser.y:2
package main

import __yyfmt__ "fmt"

//line parser.y:2

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
)

var cmp *compiler
var prep = true

//line parser.y:18
type parserSymType struct {
	yys    int
	num    int
	ident  string
	varid  string
	varids []string
	ary    aryentry
}

const NUM = 57346
const IDENT = 57347
const PLUS = 57348
const MINUS = 57349
const XOR = 57350
const MULT = 57351
const DIV = 57352
const MOD = 57353
const AND = 57354
const OR = 57355
const BITAND = 57356
const BITOR = 57357
const LEQ = 57358
const GEQ = 57359
const NEQ = 57360
const EQ = 57361
const LES = 57362
const GRT = 57363
const LSB = 57364
const RSB = 57365
const LCB = 57366
const RCB = 57367
const COMMA = 57368
const LPR = 57369
const RPR = 57370
const PROCEDURE = 57371
const MAIN = 57372
const INT = 57373
const IF = 57374
const THEN = 57375
const ELSE = 57376
const FI = 57377
const FROM = 57378
const DO = 57379
const LOOP = 57380
const UNTIL = 57381
const LOCAL = 57382
const DELOCAL = 57383
const CALL = 57384
const UNCALL = 57385
const PAR = 57386
const RAP = 57387
const SKIP = 57388
const BEGIN = 57389
const END = 57390
const P = 57391
const V = 57392

var parserToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUM",
	"IDENT",
	"PLUS",
	"MINUS",
	"XOR",
	"MULT",
	"DIV",
	"MOD",
	"AND",
	"OR",
	"BITAND",
	"BITOR",
	"LEQ",
	"GEQ",
	"NEQ",
	"EQ",
	"LES",
	"GRT",
	"LSB",
	"RSB",
	"LCB",
	"RCB",
	"COMMA",
	"LPR",
	"RPR",
	"PROCEDURE",
	"MAIN",
	"INT",
	"IF",
	"THEN",
	"ELSE",
	"FI",
	"FROM",
	"DO",
	"LOOP",
	"UNTIL",
	"LOCAL",
	"DELOCAL",
	"CALL",
	"UNCALL",
	"PAR",
	"RAP",
	"SKIP",
	"BEGIN",
	"END",
	"P",
	"V",
}

var parserStatenames = [...]string{}

const parserEofCode = 1
const parserErrCode = 2
const parserInitialStackSize = 16

//line parser.y:662

type aryentry struct {
	val string
	lab string
}

//yylval of type parserSymType provides
//yylval.<tokenname>

// Extremely dirty lexer
type token struct {
	reg     *regexp.Regexp
	process func(match string, yylval *parserSymType) int
}

type compiler struct {
	stackdepth    []int
	tmpindex      int
	labelindex    int
	output        map[string]string
	currentproc   []string
	callingproc   string
	procid        map[string]int      //fib -> 1 (its block id)
	procargs      map[string][]string // fib.0.0 -> [n,r]
	argindex      int
	recindex      int
	tokenrec      string
	dorectoken    bool
	prevtoken     string
	currentrecord string
	earlyexec     map[string]string
	lateexec      map[string]string
}

func newCompiler() *compiler {
	s := make([]int, 1, 1)
	s[0] = -1
	return &compiler{s, 0, 0, make(map[string]string), make([]string, 0), "", make(map[string]int), make(map[string][]string), 0, 0, "", false, "", "", make(map[string]string), make(map[string]string)}
}

func (c *compiler) getLabel() string {
	t := c.labelindex
	c.labelindex++
	return "l" + strconv.Itoa(t)
}

func (c *compiler) getTmp() string {
	t := c.tmpindex
	c.tmpindex++
	return "$tmp" + strconv.Itoa(t)
}
func (c *compiler) getBlockId() string {
	name := ""
	for i := range len(c.stackdepth) - 1 {
		if i != 0 {
			name += "."
		}
		name += strconv.Itoa(c.stackdepth[i])
	}
	return name
}
func (c *compiler) getIdMod() string {
	name := ""
	for i := range len(c.stackdepth) - 1 {
		name += "."
		name += strconv.Itoa(c.stackdepth[i])
	}
	return name
}
func (c *compiler) getRec() string {
	t := c.recindex
	c.recindex++
	return "rec" + strconv.Itoa(t)
}
func (c *compiler) indent() {
	//increment last(used to be shadow) & append new shadow as -1
	c.stackdepth[len(c.stackdepth)-1]++
	c.stackdepth = append(c.stackdepth, -1)
}
func (c *compiler) unindent() {
	//delete one shadow (thus making it one shorter)
	c.stackdepth = c.stackdepth[:len(c.stackdepth)-1]
}
func (c *compiler) exec(s string) {
	if c.currentrecord != "" {
		c.earlyexec[c.currentrecord] += s
		c.earlyexec[c.currentrecord] += "\n"
	} else if !c.dorectoken {
		c.output[c.currentproc[len(c.currentproc)-1]] += s
		c.output[c.currentproc[len(c.currentproc)-1]] += "\n"
	}
}

// same as exec but recorded on lateexec rather than earlyexec
func (c *compiler) unexec(s string) {
	if c.currentrecord != "" {
		c.lateexec[c.currentrecord] += s
		c.lateexec[c.currentrecord] += "\n"
	} else if !c.dorectoken {
		c.output[c.currentproc[len(c.currentproc)-1]] += s
		c.output[c.currentproc[len(c.currentproc)-1]] += "\n"
	}
}

func (c *compiler) addProc(name string) {
	s := name + c.getIdMod()
	c.procid[s] = c.stackdepth[len(c.stackdepth)-1] + 1 //nextmod
	c.procargs[s] = make([]string, 0)
	c.output[s] = ""
	c.beginProc(name)
}
func (c *compiler) addProcArg(arg string) {
	c.procargs[c.currentproc[len(c.currentproc)-1]] = append(c.procargs[c.currentproc[len(c.currentproc)-1]], arg)
}
func (c *compiler) beginProc(name string) {
	c.currentproc = append(c.currentproc, name+c.getIdMod())
}
func (c *compiler) endProc() {
	c.currentproc = c.currentproc[:len(c.currentproc)-1]
}
func (c *compiler) setCallingProc(name string) {
	c.callingproc = name
}
func (c *compiler) getProcArg() string {
	s := c.procargs[c.callingproc][c.argindex]
	c.argindex++
	return s
}
func (c *compiler) getCallingProcId() string {
	return strconv.Itoa(c.procid[c.callingproc])
}
func (c *compiler) resetArgIndex() {
	c.argindex = 0
}
func (c *compiler) getNextMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-1] + 1)
}
func (c *compiler) getPrevNextMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-1])
}
func (c *compiler) getCurrentMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-2])
}
func (c *compiler) getCurrentProc() string {
	return c.currentproc[len(c.currentproc)-1]
}
func (c *compiler) getParCount() int {
	return c.stackdepth[len(c.stackdepth)-1]
}
func (c *compiler) beginRecord(key string) {
	c.earlyexec[key] = ""
	c.lateexec[key] = ""
	c.currentrecord = key
}

func (c *compiler) execEarlyRecord(key string) {
	outd := c.currentproc[len(c.currentproc)-1]
	c.output[outd] += "{{" + key + ",early}}"
}

func (c *compiler) execLateRecord(key string) {
	outd := c.currentproc[len(c.currentproc)-1]
	c.output[outd] += "{{" + key + ",late}}"
}

func (c *compiler) endRecord(key string) {
	c.currentrecord = ""
}
func (c *compiler) recordToken() {
	c.dorectoken = true
	c.tokenrec = ""
	c.prevtoken = ""
}
func (c *compiler) getRecordedToken() string {
	c.dorectoken = false
	return c.tokenrec
}

func (c *compiler) reset() {
	c.currentproc = make([]string, 0)
	c.callingproc = ""
	c.stackdepth = make([]int, 1, 1)
	c.stackdepth[0] = -1
}
func (c *compiler) export() string {
	s := ""
	for _, v := range c.output {
		for k, v1 := range c.earlyexec {
			v = strings.ReplaceAll(v, "{{"+k+",early}}", v1)
		}
		for k, v1 := range c.lateexec {
			sl := strings.Split(v1, "\n")
			ns := ""
			slices.Reverse(sl)
			for _, v2 := range sl {
				if v2 != "" {
					ns += v2
					ns += "\n"
				}
			}
			v = strings.ReplaceAll(v, "{{"+k+",late}}", ns)
		}
		s += v
		s += "\n"
	}
	return s
}

type progLex struct {
	input  string
	tokens []token
}

func newLexer(filename string) *progLex {
	file, _ := os.ReadFile(filename)
	tokens := make([]token, 0, 30)
	//add token stuff
	//special chars
	tokens = append(tokens, token{regexp.MustCompile(`^\+`),
		func(match string, yylval *parserSymType) int {
			return PLUS
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^-`),
		func(match string, yylval *parserSymType) int {
			return MINUS
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\^`),
		func(match string, yylval *parserSymType) int {
			return XOR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\*`),
		func(match string, yylval *parserSymType) int {
			return MULT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^/`),
		func(match string, yylval *parserSymType) int {
			return DIV
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^%`),
		func(match string, yylval *parserSymType) int {
			return MOD
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^&&`),
		func(match string, yylval *parserSymType) int {
			return AND
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^||`),
		func(match string, yylval *parserSymType) int {
			return OR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^&`),
		func(match string, yylval *parserSymType) int {
			return BITAND
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^|`),
		func(match string, yylval *parserSymType) int {
			return BITOR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^<=`),
		func(match string, yylval *parserSymType) int {
			return LEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^>=`),
		func(match string, yylval *parserSymType) int {
			return GEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^!=`),
		func(match string, yylval *parserSymType) int {
			return NEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^=`),
		func(match string, yylval *parserSymType) int {
			return EQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^<`),
		func(match string, yylval *parserSymType) int {
			return LES
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^>`),
		func(match string, yylval *parserSymType) int {
			return GRT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\(`),
		func(match string, yylval *parserSymType) int {
			return LPR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\)`),
		func(match string, yylval *parserSymType) int {
			return RPR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\[`),
		func(match string, yylval *parserSymType) int {
			return LSB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\]`),
		func(match string, yylval *parserSymType) int {
			return RSB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^{`),
		func(match string, yylval *parserSymType) int {
			return LCB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^}`),
		func(match string, yylval *parserSymType) int {
			return RCB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^,`),
		func(match string, yylval *parserSymType) int {
			return COMMA
		}})
	//keywords
	//word boundary come in handy
	tokens = append(tokens, token{regexp.MustCompile(`^V\b`),
		func(match string, yylval *parserSymType) int {
			return V
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^P\b`),
		func(match string, yylval *parserSymType) int {
			return P
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^procedure\b`),
		func(match string, yylval *parserSymType) int {
			return PROCEDURE
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^main\b`),
		func(match string, yylval *parserSymType) int {
			return MAIN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^int\b`),
		func(match string, yylval *parserSymType) int {
			return INT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^if\b`),
		func(match string, yylval *parserSymType) int {
			return IF
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^then\b`),
		func(match string, yylval *parserSymType) int {
			return THEN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^else\b`),
		func(match string, yylval *parserSymType) int {
			return ELSE
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^fi\b`),
		func(match string, yylval *parserSymType) int {
			return FI
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^from\b`),
		func(match string, yylval *parserSymType) int {
			return FROM
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^do\b`),
		func(match string, yylval *parserSymType) int {
			return DO
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^loop\b`),
		func(match string, yylval *parserSymType) int {
			return LOOP
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^until\b`),
		func(match string, yylval *parserSymType) int {
			return UNTIL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^local\b`),
		func(match string, yylval *parserSymType) int {
			return LOCAL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^delocal\b`),
		func(match string, yylval *parserSymType) int {
			return DELOCAL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^call\b`),
		func(match string, yylval *parserSymType) int {
			return CALL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^uncall\b`),
		func(match string, yylval *parserSymType) int {
			return UNCALL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^par\b`),
		func(match string, yylval *parserSymType) int {
			return PAR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^rap\b`),
		func(match string, yylval *parserSymType) int {
			return RAP
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^begin\b`),
		func(match string, yylval *parserSymType) int {
			return BEGIN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^end\b`),
		func(match string, yylval *parserSymType) int {
			return END
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^skip\b`),
		func(match string, yylval *parserSymType) int {
			return SKIP
		}})
	//integer constants
	tokens = append(tokens, token{regexp.MustCompile(`^-?\d+`),
		func(match string, yylval *parserSymType) int {
			n, _ := strconv.Atoi(match)
			yylval.num = n
			return NUM
		}})
	//identifier (variable / func / whatever)
	tokens = append(tokens, token{regexp.MustCompile(`^\w+`),
		func(match string, yylval *parserSymType) int {
			yylval.ident = match
			return IDENT
		}})
	return &progLex{string(file), tokens}
}

func (x *progLex) Lex(yylval *parserSymType) int {
	x.input = strings.TrimLeft(x.input, "\r\n\t\f\v ") //remove whitespaces
	if len(x.input) == 0 {
		return 0
	}
	for _, v := range x.tokens {
		s := v.reg.FindString(x.input)
		if s != "" {
			x.input = strings.TrimPrefix(x.input, s)
			if cmp.dorectoken {
				cmp.tokenrec += cmp.prevtoken
				cmp.prevtoken = s
			}
			return v.process(s, yylval)
		}
	}
	panic("Token not found")
}

func (x *progLex) Error(s string) {
	panic(s)
}

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "usage: %s [args] file\n", os.Args[0])
		flag.PrintDefaults()
	}
	outfname := flag.String("o", "a.crl", "Specifies output `file`. Default is a.crl")
	flag.Parse()
	infname := flag.Arg(0)
	lexer := newLexer(infname)
	cmp = newCompiler()
	parserParse(lexer)
	prep = false
	lexer = newLexer(infname)
	cmp.reset()
	parserParse(lexer)
	outf, _ := os.Create(*outfname)
	defer outf.Close()
	outwriter := bufio.NewWriter(outf)
	outwriter.WriteString(cmp.export())
	outwriter.Flush()
}

//line yacctab:1
var parserExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 53,
	40, 64,
	-2, 23,
}

const parserPrivate = 57344

const parserLast = 227

var parserAct = [...]uint8{
	115, 44, 35, 157, 83, 120, 181, 118, 116, 69,
	90, 121, 109, 47, 117, 72, 203, 94, 214, 208,
	119, 199, 213, 204, 195, 206, 112, 31, 17, 7,
	29, 136, 53, 96, 97, 59, 6, 21, 3, 61,
	49, 180, 20, 12, 50, 182, 177, 131, 13, 10,
	51, 91, 52, 22, 43, 221, 122, 56, 55, 133,
	70, 57, 98, 60, 53, 33, 138, 139, 141, 140,
	142, 143, 62, 63, 64, 92, 89, 93, 26, 87,
	88, 136, 136, 19, 113, 34, 16, 114, 65, 78,
	95, 160, 153, 28, 212, 159, 86, 106, 107, 85,
	84, 123, 124, 125, 126, 127, 128, 110, 82, 27,
	81, 80, 136, 137, 209, 135, 129, 130, 144, 145,
	147, 132, 4, 152, 148, 149, 150, 146, 8, 151,
	66, 67, 68, 158, 154, 96, 97, 134, 77, 76,
	155, 71, 58, 23, 9, 161, 163, 164, 165, 166,
	167, 168, 162, 73, 173, 174, 175, 176, 156, 178,
	179, 108, 220, 215, 183, 169, 170, 171, 172, 197,
	191, 75, 217, 205, 196, 189, 210, 201, 192, 184,
	105, 104, 103, 102, 185, 188, 186, 101, 187, 100,
	193, 99, 194, 190, 46, 45, 42, 41, 198, 40,
	200, 202, 39, 38, 37, 36, 54, 207, 111, 74,
	211, 79, 32, 25, 216, 15, 218, 11, 219, 30,
	24, 18, 14, 5, 2, 1, 48,
}

var parserPact = [...]int16{
	9, -1000, 7, -1, -1000, 7, 139, 22, -1000, -1000,
	15, 21, -1000, -3, 59, 14, 27, 138, -1000, -1000,
	54, -1000, -3, 71, -4, -1000, -1000, 27, 62, 8,
	-4, 137, 8, -1000, -1000, 38, 8, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 66, 124, -1000,
	-1000, 136, -1000, -1000, -1000, 134, 133, -1000, 67, -1000,
	-1000, -1000, 92, 91, 89, -1000, 81, 80, 77, -1000,
	-1000, -1000, 25, 40, 8, -23, -1000, -1000, 131, 37,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-33, -1000, -1000, -1000, -5, 61, -1000, 65, -1000, 29,
	29, 29, 29, 29, 29, 29, -1000, -1000, 20, -1000,
	25, 34, 132, -1000, 29, 99, 101, 50, 112, 115,
	-1000, -1000, 29, 99, 99, 69, 99, 99, 99, -1000,
	-1000, 128, -1000, -1000, 76, 68, 29, 29, 29, 29,
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
	29, 29, 18, -1000, -1000, -1000, 13, 19, -1000, -1000,
	-1000, 101, 50, 112, 112, 112, 112, 112, 112, 115,
	115, 115, 115, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, 128, -1000, 29, -1000, 19, -1000, 99, 29,
	-1000, 29, -9, 99, 99, 8, -16, 8, -1000, 40,
	-25, -11, -1000, -6, 8, -19, 109, -1000, 40, 75,
	-13, -21, -1000, 29, -1000, 29, 99, 29, 99, 99,
	30, -1000,
}

var parserPgo = [...]uint8{
	0, 11, 0, 8, 14, 7, 20, 5, 9, 4,
	226, 225, 224, 122, 223, 222, 221, 220, 30, 2,
	219, 217, 215, 213, 212, 211, 86, 37, 1, 209,
	208, 206, 205, 204, 203, 202, 199, 197, 196, 195,
	194, 191, 189, 187, 183, 182, 181, 180, 179, 178,
	177, 176, 175, 174, 173, 172, 171, 170, 169, 163,
	162, 161, 158, 15, 10, 153, 3, 6,
}

var parserR1 = [...]int8{
	0, 11, 13, 13, 15, 12, 17, 16, 18, 18,
	20, 20, 21, 14, 24, 25, 23, 22, 22, 27,
	27, 26, 26, 29, 30, 28, 28, 19, 19, 32,
	32, 32, 32, 32, 32, 32, 32, 32, 32, 41,
	33, 42, 33, 43, 33, 44, 10, 45, 34, 46,
	34, 47, 34, 48, 49, 50, 51, 35, 8, 52,
	53, 54, 55, 36, 56, 57, 58, 59, 60, 31,
	61, 37, 38, 64, 64, 65, 63, 62, 62, 67,
	67, 66, 39, 40, 9, 2, 2, 3, 3, 4,
	4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
	5, 6, 6, 6, 6, 6, 7, 7, 1, 1,
	1,
}

var parserR2 = [...]int8{
	0, 2, 2, 0, 0, 6, 0, 5, 2, 0,
	2, 5, 0, 7, 0, 0, 5, 2, 0, 3,
	0, 2, 4, 0, 0, 5, 1, 2, 0, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
	5, 0, 5, 0, 5, 0, 6, 0, 5, 0,
	5, 0, 5, 0, 0, 0, 0, 18, 0, 0,
	0, 0, 0, 19, 0, 0, 0, 0, 0, 20,
	0, 7, 4, 3, 0, 0, 2, 2, 0, 3,
	0, 1, 2, 2, 0, 1, 3, 1, 3, 1,
	3, 3, 3, 3, 3, 3, 1, 3, 3, 3,
	3, 1, 3, 3, 3, 3, 1, 3, 1, 1,
	4,
}

var parserChk = [...]int16{
	-1000, -11, -12, 29, -13, -14, 29, 30, -13, 5,
	27, -21, 28, 27, -15, -22, -26, 31, -16, 24,
	28, -27, 26, 5, -17, -23, 24, -26, 22, -18,
	-20, 31, -24, -27, 23, -19, -32, -33, -34, -35,
	-36, -37, -38, 46, -28, -39, -40, 5, -10, 32,
	36, 42, 44, 24, -31, 50, 49, -18, 5, -19,
	25, -19, 6, 7, 8, 22, 6, 7, 8, -8,
	-8, 5, -63, -65, -29, -56, 5, 5, 22, -25,
	19, 19, 19, -9, 19, 19, 19, -8, -8, -9,
	-64, 26, -28, -19, 40, -1, 4, 5, 25, -41,
	-42, -43, -44, -45, -46, -47, -8, -8, -61, 45,
	-63, -30, 31, 23, 22, -2, -3, -4, -5, -6,
	-7, -1, 27, -2, -2, -2, -2, -2, -2, -8,
	-8, 27, -64, 25, 5, -2, 13, 12, 16, 17,
	19, 18, 20, 21, 6, 7, 15, 8, 9, 10,
	11, 14, -2, 23, -9, -8, -62, -66, 5, 19,
	23, -3, -4, -5, -5, -5, -5, -5, -5, -6,
	-6, -6, -6, -7, -7, -7, -7, 28, -9, -9,
	28, -67, 26, -9, -48, -9, -66, -9, -2, -52,
	-67, -57, -49, -2, -2, 33, -53, -58, -19, 37,
	-19, -50, -28, 41, 34, -54, 31, -19, 38, 5,
	-51, -28, 19, 35, 39, -59, -2, -55, -2, -2,
	-60, 25,
}

var parserDef = [...]int8{
	0, -2, 3, 0, 1, 3, 0, 0, 2, 12,
	0, 0, 4, 18, 0, 0, 20, 0, 5, 6,
	0, 17, 0, 21, 9, 13, 14, 20, 0, 28,
	9, 0, 28, 19, 22, 0, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 0, 0, 58,
	58, 0, 75, -2, 26, 0, 0, 8, 10, 15,
	7, 27, 0, 0, 0, 84, 0, 0, 0, 58,
	58, 84, 74, 0, 28, 0, 82, 83, 0, 0,
	39, 41, 43, 45, 47, 49, 51, 58, 58, 70,
	0, 75, 76, 24, 0, 0, 108, 109, 16, 0,
	0, 0, 0, 0, 0, 0, 58, 58, 0, 72,
	74, 0, 0, 11, 0, 40, 85, 87, 89, 96,
	101, 106, 0, 42, 44, 0, 48, 50, 52, 84,
	58, 78, 73, 25, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 46, 84, 84, 0, 80, 81, 84,
	110, 86, 88, 90, 91, 92, 93, 94, 95, 97,
	98, 99, 100, 102, 103, 104, 105, 107, 53, 84,
	71, 77, 0, 84, 0, 59, 80, 65, 54, 0,
	79, 0, 0, 60, 66, 28, 0, 28, 55, 0,
	0, 0, 61, 0, 28, 0, 0, 56, 0, 0,
	0, 0, 67, 0, 62, 0, 57, 0, 68, 63,
	0, 69,
}

var parserTok1 = [...]int8{
	1,
}

var parserTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50,
}

var parserTok3 = [...]int8{
	0,
}

var parserErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	parserDebug        = 0
	parserErrorVerbose = false
)

type parserLexer interface {
	Lex(lval *parserSymType) int
	Error(s string)
}

type parserParser interface {
	Parse(parserLexer) int
	Lookahead() int
}

type parserParserImpl struct {
	lval  parserSymType
	stack [parserInitialStackSize]parserSymType
	char  int
}

func (p *parserParserImpl) Lookahead() int {
	return p.char
}

func parserNewParser() parserParser {
	return &parserParserImpl{}
}

const parserFlag = -1000

func parserTokname(c int) string {
	if c >= 1 && c-1 < len(parserToknames) {
		if parserToknames[c-1] != "" {
			return parserToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func parserStatname(s int) string {
	if s >= 0 && s < len(parserStatenames) {
		if parserStatenames[s] != "" {
			return parserStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func parserErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !parserErrorVerbose {
		return "syntax error"
	}

	for _, e := range parserErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + parserTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(parserPact[state])
	for tok := TOKSTART; tok-1 < len(parserToknames); tok++ {
		if n := base + tok; n >= 0 && n < parserLast && int(parserChk[int(parserAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if parserDef[state] == -2 {
		i := 0
		for parserExca[i] != -1 || int(parserExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; parserExca[i] >= 0; i += 2 {
			tok := int(parserExca[i])
			if tok < TOKSTART || parserExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if parserExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += parserTokname(tok)
	}
	return res
}

func parserlex1(lex parserLexer, lval *parserSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(parserTok1[0])
		goto out
	}
	if char < len(parserTok1) {
		token = int(parserTok1[char])
		goto out
	}
	if char >= parserPrivate {
		if char < parserPrivate+len(parserTok2) {
			token = int(parserTok2[char-parserPrivate])
			goto out
		}
	}
	for i := 0; i < len(parserTok3); i += 2 {
		token = int(parserTok3[i+0])
		if token == char {
			token = int(parserTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(parserTok2[1]) /* unknown char */
	}
	if parserDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", parserTokname(token), uint(char))
	}
	return char, token
}

func parserParse(parserlex parserLexer) int {
	return parserNewParser().Parse(parserlex)
}

func (parserrcvr *parserParserImpl) Parse(parserlex parserLexer) int {
	var parsern int
	var parserVAL parserSymType
	var parserDollar []parserSymType
	_ = parserDollar // silence set and not used
	parserS := parserrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	parserstate := 0
	parserrcvr.char = -1
	parsertoken := -1 // parserrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		parserstate = -1
		parserrcvr.char = -1
		parsertoken = -1
	}()
	parserp := -1
	goto parserstack

ret0:
	return 0

ret1:
	return 1

parserstack:
	/* put a state and value onto the stack */
	if parserDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", parserTokname(parsertoken), parserStatname(parserstate))
	}

	parserp++
	if parserp >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserS[parserp] = parserVAL
	parserS[parserp].yys = parserstate

parsernewstate:
	parsern = int(parserPact[parserstate])
	if parsern <= parserFlag {
		goto parserdefault /* simple state */
	}
	if parserrcvr.char < 0 {
		parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
	}
	parsern += parsertoken
	if parsern < 0 || parsern >= parserLast {
		goto parserdefault
	}
	parsern = int(parserAct[parsern])
	if int(parserChk[parsern]) == parsertoken { /* valid shift */
		parserrcvr.char = -1
		parsertoken = -1
		parserVAL = parserrcvr.lval
		parserstate = parsern
		if Errflag > 0 {
			Errflag--
		}
		goto parserstack
	}

parserdefault:
	/* default state action */
	parsern = int(parserDef[parserstate])
	if parsern == -2 {
		if parserrcvr.char < 0 {
			parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if parserExca[xi+0] == -1 && int(parserExca[xi+1]) == parserstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			parsern = int(parserExca[xi+0])
			if parsern < 0 || parsern == parsertoken {
				break
			}
		}
		parsern = int(parserExca[xi+1])
		if parsern < 0 {
			goto ret0
		}
	}
	if parsern == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			parserlex.Error(parserErrorMessage(parserstate, parsertoken))
			Nerrs++
			if parserDebug >= 1 {
				__yyfmt__.Printf("%s", parserStatname(parserstate))
				__yyfmt__.Printf(" saw %s\n", parserTokname(parsertoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for parserp >= 0 {
				parsern = int(parserPact[parserS[parserp].yys]) + parserErrCode
				if parsern >= 0 && parsern < parserLast {
					parserstate = int(parserAct[parsern]) /* simulate a shift of "error" */
					if int(parserChk[parserstate]) == parserErrCode {
						goto parserstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if parserDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", parserS[parserp].yys)
				}
				parserp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if parserDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", parserTokname(parsertoken))
			}
			if parsertoken == parserEofCode {
				goto ret1
			}
			parserrcvr.char = -1
			parsertoken = -1
			goto parsernewstate /* try again in the same state */
		}
	}

	/* reduction by production parsern */
	if parserDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", parsern, parserStatname(parserstate))
	}

	parsernt := parsern
	parserpt := parserp
	_ = parserpt // guard against "declared and not used"

	parserp -= int(parserR2[parsern])
	// parserp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if parserp+1 >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserVAL = parserS[parserp+1]

	/* consult goto table to find next state */
	parsern = int(parserR1[parsern])
	parserg := int(parserPgo[parsern])
	parserj := parserg + parserS[parserp].yys + 1

	if parserj >= parserLast {
		parserstate = int(parserAct[parserg])
	} else {
		parserstate = int(parserAct[parserj])
		if int(parserChk[parserstate]) != -parsern {
			parserstate = int(parserAct[parserg])
		}
	}
	// dummy call; replaced with literal code
	switch parsernt {

	case 4:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:38
		{
			if prep {
				cmp.addProc("main")
			} else {
				cmp.beginProc("main")
				cmp.exec("begin main")
			}
		}
	case 5:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:47
		{
			if !prep {
				cmp.exec("end main")
			}
			cmp.endProc()
		}
	case 6:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:55
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 7:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:62
		{
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 10:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:72
		{
			if !prep {
				cmp.exec("#" + parserDollar[2].ident + " += 0")
			}
		}
	case 11:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:78
		{
			if !prep {
				cmp.exec("#" + parserDollar[2].ident + "[" + parserDollar[4].varid + "]" + " += 0")
			}
		}
	case 12:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:85
		{
			if prep {
				cmp.addProc(parserDollar[2].ident)
			} else {
				cmp.beginProc(parserDollar[2].ident)
				cmp.exec("begin " + parserDollar[2].ident)
			}
		}
	case 13:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:94
		{
			if !prep {
				cmp.exec("end " + parserDollar[2].ident)
			}
			cmp.endProc()
		}
	case 14:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:102
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 15:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:109
		{
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 21:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:125
		{
			if prep {
				cmp.addProcArg(parserDollar[2].ident)
			}
		}
	case 22:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:131
		{
			if prep {
				cmp.addProcArg(parserDollar[2].ident)
			}
		}
	case 23:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:138
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 24:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:145
		{
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 39:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:169
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 40:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:175
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " += " + cmp.getRecordedToken())
			}

		}
	case 41:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:182
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 42:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:188
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " -= " + cmp.getRecordedToken())
			}

		}
	case 43:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:195
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 44:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:201
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " ^= " + cmp.getRecordedToken())
			}

		}
	case 45:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:208
		{
			if !prep {
				cmp.beginRecord(parserDollar[3].varid)
			}
		}
	case 46:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:214
		{
			if !prep {
				cmp.endRecord(parserDollar[3].varid)
				parserVAL.varid = parserDollar[1].ident + "[" + parserDollar[5].varid + "]"
			}
		}
	case 47:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:221
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 48:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:227
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " += " + cmp.getRecordedToken())
			}

		}
	case 49:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:234
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 50:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:240
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " -= " + cmp.getRecordedToken())
			}

		}
	case 51:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:247
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 52:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:253
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " ^= " + cmp.getRecordedToken())
			}

		}
	case 53:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:261
		{
			if !prep {
				cmp.beginRecord(parserDollar[6].varid)
			}
		}
	case 54:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:267
		{
			if !prep {
				cmp.endRecord(parserDollar[6].varid)
				cmp.execEarlyRecord(parserDollar[6].varid)
				cmp.exec(parserDollar[9].varid + " -> " + parserDollar[2].varid + ";" + parserDollar[3].varid)
				cmp.exec(parserDollar[2].varid + " <-")
				cmp.execLateRecord(parserDollar[6].varid)
			}
		}
	case 55:
		parserDollar = parserS[parserpt-12 : parserpt+1]
//line parser.y:277
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[4].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.execLateRecord(parserDollar[6].varid)
			}
		}
	case 56:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:286
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[5].varid)
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 57:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:294
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.exec(parserDollar[4].varid + ";" + parserDollar[5].varid + " <- " + parserDollar[18].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 58:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:303
		{
			if !prep {
				parserVAL.varid = cmp.getLabel()
			}
		}
	case 59:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:310
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 60:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:316
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[2].varid)
				cmp.exec(parserDollar[2].varid + ";" + parserDollar[6].varid + " <- " + parserDollar[10].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 61:
		parserDollar = parserS[parserpt-13 : parserpt+1]
//line parser.y:326
		{
			if !prep {
				cmp.exec("-> " + parserDollar[3].varid)
				cmp.exec(parserDollar[5].varid + " <-")
				cmp.execLateRecord(parserDollar[8].varid)
			}
		}
	case 62:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:334
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[6].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.beginRecord(parserDollar[8].varid)
			}
		}
	case 63:
		parserDollar = parserS[parserpt-19 : parserpt+1]
//line parser.y:343
		{
			if !prep {
				cmp.endRecord(parserDollar[8].varid)
				cmp.execEarlyRecord(parserDollar[8].varid)
				cmp.exec(parserDollar[19].varid + " -> " + parserDollar[4].varid + ";" + parserDollar[5].varid)
				cmp.exec(parserDollar[4].varid + " <-")
				cmp.execLateRecord(parserDollar[8].varid)
			}
		}
	case 64:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:354
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 65:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:361
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 66:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:367
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("$" + parserDollar[5].ident + " += " + parserDollar[10].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 67:
		parserDollar = parserS[parserpt-16 : parserpt+1]
//line parser.y:376
		{
			if !prep {
				cmp.beginRecord(parserDollar[8].varid)
			}
		}
	case 68:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:382
		{
			if !prep {
				cmp.endRecord(parserDollar[8].varid)
				cmp.execEarlyRecord(parserDollar[8].varid)
				cmp.exec("$" + parserDollar[15].ident + " -= " + parserDollar[18].varid)
				cmp.execLateRecord(parserDollar[8].varid)
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 70:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:395
		{
			if !prep {
				cmp.setCallingProc(parserDollar[2].ident)
				cmp.beginRecord(parserDollar[3].varid)
				cmp.argindex = 0
			}
		}
	case 71:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:403
		{
			if !prep {
				cmp.endRecord(parserDollar[3].varid)
				cmp.argindex = 0
				cmp.execEarlyRecord(parserDollar[3].varid)
				cmp.exec("call " + parserDollar[2].ident)
				cmp.execLateRecord(parserDollar[3].varid)
			}
		}
	case 72:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:414
		{
			if !prep {
				s := ""
				for i := range cmp.getParCount() + 1 {
					if i != 0 {
						s += ","
					}
					s += " "
					s += "$" + cmp.getBlockId() + "." + strconv.Itoa(i)
				}
				cmp.exec("call" + s)
			}
		}
	case 75:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:432
		{
			if prep {
				cmp.addProc("$" + cmp.getBlockId() + "." + cmp.getNextMod())
			}
			if !prep {
				cmp.beginProc("$" + cmp.getBlockId() + "." + cmp.getNextMod())
				cmp.exec("begin $" + cmp.getBlockId() + "." + cmp.getNextMod())
			}
		}
	case 76:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:442
		{
			if !prep {
				cmp.exec("end $" + cmp.getBlockId() + "." + cmp.getPrevNextMod())
			}
			cmp.endProc()
		}
	case 81:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:457
		{
			if !prep {
				i := cmp.getProcArg()
				cmp.exec("set $" + i + ":" + cmp.getCallingProcId() + " " + parserDollar[1].ident)
				cmp.unexec("unset $" + i + ":" + cmp.getCallingProcId() + " " + parserDollar[1].ident)
			}
		}
	case 82:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:466
		{
			if !prep {
				cmp.exec("V " + parserDollar[2].ident)
			}
		}
	case 83:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:472
		{
			if !prep {
				cmp.exec("P " + parserDollar[2].ident)
			}
		}
	case 84:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:479
		{
			parserVAL.varid = cmp.getRec()
		}
	case 85:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:484
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 86:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:488
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				cmp.exec(tmp + " -= " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 87:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:497
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 88:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:501
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 89:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:511
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 90:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:515
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 91:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:524
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 92:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:533
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 93:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:542
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 94:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:551
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 95:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:560
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 96:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:569
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 97:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:573
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 98:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:582
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 100:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:592
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 101:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:601
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 102:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:605
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 103:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:614
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 104:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:623
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 106:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:634
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 107:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:638
		{
			parserVAL.varid = parserDollar[2].varid
		}
	case 108:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:643
		{
			if !prep {
				parserVAL.varid = strconv.Itoa(parserDollar[1].num)
			}
		}
	case 109:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:649
		{
			if !prep {
				parserVAL.varid = parserDollar[1].ident
			}
		}
	case 110:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:655
		{
			if !prep {
				parserVAL.varid = parserDollar[1].ident + "[" + parserDollar[3].varid + "]"
			}
		}
	}
	goto parserstack /* stack new state and value */
}
